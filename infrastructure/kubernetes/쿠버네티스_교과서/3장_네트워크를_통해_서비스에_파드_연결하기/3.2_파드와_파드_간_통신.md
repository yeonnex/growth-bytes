<!-- Date: 2025-01-31 -->
<!-- Update Date: 2025-02-01 -->
<!-- File ID: ed8a5a31-6526-442d-befd-3f3a0dd7c7e4 -->
<!-- Author: Seoyeon Jang -->

# 개요

서비스의 유형 중 가장 기본이 되는 것을 클러스터IP(ClusterIP)라고 한다. 클러스터IP는 클러스터 전체에서 통용되는 IP주소를 생성하는데, 이 주소는 파드가 어느 노드에 있더라도 접근이 가능하다. 하지만 이
IP주소는 클러스터 내에서만 유효하다. 따라서 **클러스터IP는 파드와 파드 간 통신에서만 쓰인다.** 내부에서는 접근이 가능하되 외부의 접근은 차단해야 하는 분산 시스템의 컴포넌트에 딱 적합하다.

> 실습: 두 개의 디플로이먼트를 실행하자. 하나는 웹앱, 다른 하나는 API 역할을 담당한다. 여기에는 아직 서비스가 없다. 따라서 웹앱이 API에 접근하지 못해 애플리케이션이 제대로 동작하지 않는 상태!

```shell
# 웹사이트와 API를 담당할 두 개의 디플로이먼트를 실행한다
$ kubectl apply -f numbers/api.yaml -f numbers/web.yaml

# 웹앱에 포트포워딩을 적용한다
$ kubectl port-forward deploy/numbers-web 8080:80

# 웹브라우저에서 8080 에 접근한 뒤 Go 버튼을 클릭하면 오류가 발생한다
```

오류 메시지에는 웹사이트가 접근하려던 API의 주소(http://numbers-api)도 함께 나와 있다. 이 주소가 완전한 형태의(blog.sixeyed.com과 같은) 도메인 네임은 아니지만, 로컬 네트워크
안에서는 도메인 네임 해소에 문제없다. 하지만 현재 쿠버네티스 내부의 DNS 서버에는 numbers-api 라는 이름을 가진 서비스가 등록되어있지 않다. 그러므로 등록하자!

```yaml
# api-service.yml

apiVersion: v1
kind: Service

metadata:
  name: numbers-api

spec:
  ports:
    - port: 80
  selector:
    app: numbers-api
  type: ClusterIP
```

```shell
$ kubectl apply -f api-service.yml
```

서비스의 기본 유형은 클러스터 IP이므로 유형을 생략할 수 있다. 하지만 의미가 더 분명해지기 때문에 유형을 명시하는 것이 낫다. 서비스가 클러스터에 배포되면 웹 애플리케이션 파드와 API 파드의 통신이 가능해진다.

이 서비스 정의에는 웹 애플리케이션이 API에 접근하는 데 사용하는 도메인 네임이 포함되어 있다. `$kubectl get svc numbers-api` 를 하면 CLUSTER-IP 가 나오는데, 이 IP주소가
API파드의 대문 역할을 한다.

여기에서 중요한 것은 YAML 스크립트에 애플리케이션 전체를 정의할 수 있다는 것이다. 애플리케이션의 모든 컴포넌트, 심지어 이들 간 통신까지 말이다. 쿠버네티스에서는 애플리케이션 아키텍쳐의 세세한 부분까지 직접
YAML에 정의해주어야 한다. 이런 간단한 애플리케이션도 현재 상태처럼 동작하기 위해 두 개의 디플로이먼트, 한 개의 서비스까지 합해서 세개나 되는 쿠버네티스 리소스를 정의해야 했다. 하지만 이렇게 각 구성요소를
분할한 덕분에 **애플리케이션에 상당한 자기 회복성을 부여할 수 있었다.**

api 파드를 삭제하면, Deployment 덕분에 다시 살아난다. 이때 새로운 파드는 새 IP 주소를 부여받지만, 레이블이 일치하며, 서비스의 IP주소는 변경되지 않았기 때문에 웹 애플리케이션 파드는 전과 같은
주소로 계속 API 파드와 통신할 수 있다.

실습에서야 파드를 수동으로 삭제하며 테스트했지만 실제 운영환경에서 파드 교체는 늘상 일어나는 일이다. 컴포넌트 업데이트나 노드가 고장을 일으켜 다른 노드에서 파드가 뜨던가... 그러나 서비스가 제공하는 추상화가 있으면 이렇게 지속적인 파드 교체에도 애플리케이션이 계속 서로 통신할 수 있다.

이번 시나리오는 웹 애플리케이션 파드가 아직 클러스터 외부에서 들어오는 트래픽을 받도록 설정되지 않았기 때문에 완전한 상태는 아니다. 지금까지는 포트포워딩으로 이 설정을 대신했지만 이 방법은 디버깅을 위한 임시방편에 지나지 않는다. 원래대로라면 웹 애플리케이션 파드에 사용될 서비스도 배포해야 한다.

# 정리


