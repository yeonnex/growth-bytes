자바 스레드 객체는 처음에 `NEW` 상태로 생성된다. 이때 OS 스레드는 아직 존재하지 않으며 그 후로도존재하지 않을 수 있다. 실행 스레드를 생성하려면 `Thread.start()`를 호출해야 한다. 이는 OS가 실제로 스레드를 생성하도록 신호를 보낸다.

스케줄러는 새로운 스레드를 실행 대기열에 배치하고 나중에 실행할 코어를 찾는다(컴퓨터의 부하가 심할 경우 어느 정도 대기 시간이 소요될 수 있다). 거기서부터 스레드는 할당받은 시간을 소모해서 계속 진행하다가 다시 실행 대기열에 배치돼 추가적인 프로세서 시간 할당을 기다릴 수 있다.

코어에 배치돼 실행되고, 다시 실행 대기열에 배치되는 이 스케줄링 프로세스 내내 자바 Thread 객체는 RUNNABLE 상태로 유지된다. 스레드 자체도 자신이 현재 코어를 사용할 수 없음을 나타낼 수 있다. 이는 두가지 방법이 있다.

1. 프로그램 코드는 `Thread.sleep()`을 호출함으로써 스레드가 진행하기 전에 일정 시간을 기다려야함을 나타낸다. 
2. 스레드가 어떤 외부 조건이 충족될 때까지 기다려야 함을 인식하고 `Object.wait()`을 호출한다.

**이 두 경우 모두 스레드는 OS에 의해 즉시 코어에서 제거된다.**

그러나 그 시점 이후의 동작은 각 경우에 따라 다르다.

첫번째 경우, 스레드는 일정 시간 동안 절전모드를 요청한다. 자바 스레드가 `TIMED_WAITING`상태로 전환되고 운영체제가 타이머를 설정한다. 타이머가 만료되면 잠자고 있던 스레드가 깨어나 다시 실행할 준비가 돼 실행 대기열에 다시 배치된다.

두번째 경우는 약간 다르다. 자바의 객체별 모니터의 조건 측면을 사용한다. 이 경우 스레드는 `WAITING`상태로 전환돼 무기한 대기한다. 일반적으로 운영체제에서 조건이 충족됐다는 신호를 보낼때까지(일반적으로 다른 스레드가 현재 객체에서 `Object.notify()`를 호출함으로써 이뤄짐) 스레드는 깨어나지 않는다.

스레드를 제어할 수 있는 이 두가지 가능성 외에도 스레드가 I/O를 대기중이거나 다른 스레드가 보유한 잠금을 획득하기 위해 `BLOCKED` 상태로 전환될 수 있다. 마지막으로 자바 스레드에 해당하는 OS스레드가 실행을 중단한 경우 해당 스레드 객체는 `TERMINATED` 상태로 전환된다. 이제 동기화된 문제를 해결하는 잘 알려진 방법 중 하나인 [[완전히 동기화된 객체]]라는 개념에 대해 이야기 해보자.
