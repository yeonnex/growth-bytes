<!-- Date: 2025-01-08 -->
<!-- Update Date: 2025-01-10 -->
<!-- File ID: 5e06ae43-5420-4912-beba-aa7b14c689cf -->
<!-- Author: Seoyeon Jang -->

# 개요

기반을 탄탄히 다진 자바 개발자가 되기 위한 확실한 방법 중 하나는 플랫폼의 작동 방식에 대한 이해도를 높이는 것이다.
클래스 로딩 및 JVM 바이트코드의 특성과 같은 핵심 기능에 익숙해지면 이러한 목표를 달성하는 데 큰 도움이 될 것이다.

고급 자바 개발자가 직면할 수 있는 다음 시나리오를 생각해보자. **스프링**과 같은 **의존성 주입**기술을
많이 사용하는 애플리케이션이 있는데, 시작시 문제가 발생해서 알 수 없는 오류 메시지와 함께
실패한다고 가정해보자. 문제가 단순한 구성 오류를 넘어선다면 문제를 추적하기 위해 DI 프레임워크가 어떻게 구현되는지
이해해야 한다. 즉 **클래스 로딩을 이해해야 한다.**

또는 거래중인 공급업체가 폐업했다고 가정해보겠다. 소스코드 없이 컴파일된 코드와 패치된 문서만 남게 된다.
컴파일된 코드를 탐색하고 그 안에 무엇이 포함되는지 어떻게 확인할 수 있을까?

가장 간단한 애플리케이션조차 ClassNotFoundException 또는 NoClassDefFoundError로 실패할 수 있지만, 많은
개발자는 이러한 예외가 무엇인지, 그 차이점은 무엇인지, 심지어 왜 발생하는지조차 모른다.

**이 장에서는 이런 문제의 근간이 되는 플랫폼적인 측면에 초점을 맞춘다.**

먼저, 클래스 로딩에 대한 개요로 시작하겠다. 클래스 로딩은 JVM이 실행중인 프로그램에서 새로운 타입을 찾아 활성화하는 
과정을 말한다. 이에 관련한 주요한 주제는 JVM에서 타입을 나타내는 Class 객체다.
다음으로, 이러한 개념이 어떻게 리플렉션이라는 주요 언어 기능으로 구축되는지 살펴볼 것이다.

그 다음으로 **클래스파일**을 검사하고 분석하는 도구에 대해 설명한다.
JDK와 함께 제공되는 javap를 참조도구로 사용한다. 이 클래스 파일 해부 수업이 끝나면 바이트코드로 넘어가겠다.
JVM 명령코드(opcode) 그룹을 다루고 런타임이 저수준에서 어떻게 동작하는지 살펴볼 것이다.

먼저 실행중인 JVM 프로세스에 새로운 클래스를 통합하는 프로세스인 **클래스 로딩(class loading)** 에 대해 알아보겠다.
자바 8과 이전 버전에서 수행했던 고전적인 클래스 로딩의 기본 사항에 대해 설명하고, 모듈형 JVM의 등장으로 클래스 로딩에 어떤 변화가
생겼는지에 대해 설명한다.

# 정리


