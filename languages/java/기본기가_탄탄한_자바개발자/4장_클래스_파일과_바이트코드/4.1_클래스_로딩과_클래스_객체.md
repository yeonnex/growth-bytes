<!-- Date: 2025-01-11 -->
<!-- Update Date: 2025-01-11 -->
<!-- File ID: e05a2c93-8ab9-41eb-ab90-9950bcbb5d3b -->
<!-- Author: Seoyeon Jang -->

# 개요

.class 파일은 필드, 메서드, 상속 정보, 애너테이션, 기타 메타데이터로 구성된 JVM에서의 타입을 정의한다.
클래스 파일 포맷은 표준에 잘 설명돼 있으며, **JVM에서 실행하려는 모든 언어는 이 형식을 준수해야 한다.**

> 클래스는 자바 플랫폼이 이해하고, 받아들이고, 실행하는 프로그램 코드의 기본 단위다.

초보 개발자의 입장에서는 클래스 로딩 매커니즘의 많은 부분이 보이지 않는다. 개발자가 실행 가능한 JAR파일이나 기본
애플리케이션 클래스의 이름을 제공하면 JVM이 알아서 해당 클래스를 찾아서 잘 실행하는 것처럼 보인다.
모든 애플리케이션 의존성(예: JDK 이외의 라이브러리)도 클래스패스에 있어야 하는데, JVM은 이러한 의존성도 찾아서 로드한다.
그러나 자바 사양에는 이 작업을 애플리케이션 시작 시 수행해야 하는지 아니면 필요에 따라 나중에 수행해야 하는지는 명시돼있지 않다.

> 자바 클래스 로딩 시스템이 사용자에게 제공하는 API는 매우 간단한다. 많은 복잡성이 의도적으로 숨겨져있다.
> 뒷 부분에서 개발자가 사용할 수 있는 API에 대해 설명한다.

아주 간단한 예부터 시작하자.

```java
Class<?> clazz = Class.forName("MyClass");
```

이 코드조각은 MyClass 라는 클래스를 현재 실행상태로 로드한다.JVM의 관점에서 볼 때 이를 위해서는 여러 단계를 수행해야 한다.
먼저 MyClass라는 이름에 대해 해당하는 클래스 파일을 찾은 다음, 해당 파일에 포함된 클래스를 해석한다.
이러한 단계는 **네이티브 코드에서 수행되며, 핫스팟에서는 JVM_DefineClass()** 라는 네이티브 메서드가 이를 담당한다.

실제 프로세스는 높은 수준에서 네이티브 코드가 JVM의 내부 표현(이를 klass 라고 하며 자바 객체가 아니다. 17장에서 다룸)을 빌드하는 것이다.
그 다음 클래스 파일에서 klass 를 성공적으로 추출하면, JVM은 klass의 자바 **미러**(mirror)를 생성하고 이는
Class 객체로 자바 코드에 반환된다.

그 후 실행 중인 시스템에서 해당 타입을 나타내는 Class 객체를 사용할 수 있으며, 해당 클래스의 새로운 인스턴스를 생성할 수 있다.
앞선 예제에서 clazz 는 MyClass 타입에 해당하는 Class 객체를 보유하게 된다. 그러나 klass 는 자바 객체가 아닌
JVM 내부 객체여서 clazz 가 보유할 수 없다.

> 동일한 프로세스가 메인 애플리케이션 클래스, 그에 따른 의존성과 프로그램 시작 후 필요한 다른 모든 클래스에서도 사용된다.

여기서는 JVM의 관점에서 단계를 좀 더 알아보고, 전체 프로세스를 제어하는 객체인 클래스로더에 대해 알아보자.

# 정리


