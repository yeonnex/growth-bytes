<!-- Date: 2025-01-29 -->
<!-- Update Date: 2025-01-29 -->
<!-- File ID: d0a9c4aa-1319-4f6e-bbd9-fd2494ae0905 -->
<!-- Author: Seoyeon Jang -->

# 개요

로그를 디스크에 쓰기만 하면 된다. `docker exec` 또는 `docker cp`를 사용해서 파일에 액세스할 수 있다.

```shell
$ docker run --rm --name hello-container hello

$ docker cp hello-contailer:/log/application.log .

$ docker exec hello-container tail -f /log/application.log
```

그러나 이렇게 하면 정보를 검색하는 데 약간의 어려움이 있다. 또한 컨테이너가 조기에 완전히 제거되면 데이터 손실의 위험이 있다...

컨테이너와 무관하게 자주 사용되는 관행은 응용 프로그램에서 로그를 중앙 위치로 전달하는 것이다. 이 전달의 대상은 중앙 저장소일 수도 있으며, 엘라스틱서치와 같은 인덱싱 서비스나 완전히 외부 로깅 공급자일 수도
있다.

그러나 컨테이너 내에서 로그를 간단히 로컬 파일에 기록하는 관행을 유지하려면 로그 전달 애플리케이션을 어디에 실행할지 결졍해야한다. 컨테이너 내에 두면 추가적인 메모리와 리소스가 소비되며, 일반적으로는 하나의
컨테이너 내에 여러 가지 요소를 가지는 것을 피하는 것을 권장한다. 컨테이너에 볼륨을 마운트해서 로그 파일을 컨테이너와 호스트 간에 공유할 수 있지만, 이는 환경 설정이 필요하며 성능이 좋지 않을 수 있다.

더 나은 대안은 도커 컨테이너가 일반 출력 스트림인 STDOUT과 STDERR에 작성하는 모든 내용을 캡처한다는 점을 활용한다는 것이다. 호스트에서는 이러한 스트림이 실행되는 모든 컨테이너가 잘 알려진 파일 위치에 저장된다. 개별 컨테이너가 파일 대신 STDOUT 에 작성하도록 지시하면 된다. 또한 기존의 로깅 라이브러리인 log4j2 와 호환된다. log4j는 정확히 이 목적을 위해 CONSOLE에 작성하는 어펜더를 가지고 있다.

이런 유형의 인프라 구성은 컨테이너를 단일 호스트 이상으로 확장하는 경우에 발생하는 문제 중 하나다. 이러한 질문에 대한 체계적인 해결 방법을 제공하는 것은 다음 주제인 쿠버네티스의 주요 차이점 중 하나다.
# 정리


