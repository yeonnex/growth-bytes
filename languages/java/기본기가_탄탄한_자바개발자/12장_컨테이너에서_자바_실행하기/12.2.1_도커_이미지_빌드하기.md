<!-- Date: 2025-01-28 -->
<!-- Update Date: 2025-01-28 -->
<!-- File ID: 7dff0715-c5b5-40ba-bc9d-57864ef478c4 -->
<!-- Author: Seoyeon Jang -->

# 개요

컨테이너를 구성하는 많은 기술은 이전부터 존재했지만, 도커는 편리한 도구와 추상화를 소개해서 컨테이너를 주류화시키는 데 큰 역할을 했다. 도커가 제공하는 두가지 주요한 기능인 이미지 빌딩과 컨테이너 실행에 대해
알아보자.

도커 컨테이너는 이미지에서 시작된다. 이미지? 이미지는 실제로 소프트웨어를 실행하는 데 필요한 모든 파일시스템 의존성을 포착한 스냅샷이다. 이미지에는 네이티브 라이브러리, 프로그래밍 언어 실행환경, 도구, 그리고
가장 중요한 것으로 특정 버전의 소프트웨어가 포함돼있다.

도커 파일은 이미지를 빌드하기 위한 일련의 단계를 기록하는 일반적인 형식이다. 실제로 유용한 소프트웨어가 이미 설치된 많은 베이스 이미지가 존재한다. 자바 이미지를 빌드해보자.

```dockerfile
FROM ecplise-temurin:11
RUN java -version
```

기본적으로 최신 버전의 도커는 대화형 터미널에서 빌드할 때 출력을 동적으로 숨긴다. 여기서는 `--progress plain`을 사용해서 무슨 일이 일어나는지 명확하게 파악해보자.

처음 실행할 땐 오래 걸린다. 도커가 도커 허브에서 관련 기본 이미지를 다운로드 해야 하기 때문이다. 추가한 RUN 명령은 해당 기본 이미지 위에 새로운 단계를 도입한다. RUN 은 컨테이너 환경에서 유효한 명령을
실행할 수 있다. 명령이 파일 시스템을 변경하는 경우, 해당 변경 사항은 최종 이미지의 일부로 포함된다. 이 예제에서는 실제로 파일 시스템을 변경하지 않지만, RUN은 파일을 다운로드하거나(예: curl), 표준
패키지 관리자를 사용하여 운영체제 패키지를 설치하거나, 기타 로컬 수정을 하는 데 자주 사용된다.

도커 파일을 건드리지 않고 동일한 빌드 명령을 다시 실행하면 도커 빌드시 캐시를 사용하게 된다.

도커 파일 내의 각 주요 명령(예: FROM, RUN)은 `레이어`라고 하는 것을 생성한다. 이러한 명령은 종종 시간이 많이 소요될 수 있기 때문에 이러한 레이어는 캐시되며, 도커는 불필요한 작업을 피하기 위해
최선을 다한다.

이제 컨테이너에 자바 환경이 있으므로 자체 코드를 실행할 수 있다. 도커 파일과 함께 HelloDocker.java 라는 간단한 자바 파일을 생성해보자. 쉽게 가기 위해 전체 빌드를 구성하는 대신 자바 단일 파일로
가자.

```dockerfile
FROM eclipse-temurin:11
RUN java -version


COPY HelloDocker.java .

# 소스 파일 컴파일
RUN javac HelloDocker.java

# .class 파일 실행
CMD ["java", "HelloDocker"]
```

COPY 는 로컬 빌드 환경에서 파일을 가져와서 컨테이너에 넣는다. 특히 ADD에는 원격 소스에서 가져오기, TAR 파일 자동압축 풀기 등 다양한 옵션이 있으나 일반적으로는 가능하면 COPY를 사용하는 것이 더
좋다.

CMD는 이미지에 구성한 소프트웨어를 실행하기 위한 것이다. 각 이미지에는 고유한 SHA256 ID가 있지만, 이는 빌드할 때마다 변경해야하는 번거로운 작업이다. 이미지를 실행하기 전에 다음과 같이 이미지에 더 쉬운
이름을 지정해보자.

```shell
$ docker build -t hello .
```

현재로서는 로컬에서만 hello 이미지를 사용할 수 있지만, 이미 FROM 줄을 통해 이미지를 공유할 수 있음을 확인했다.

docker push 와 docker pull 명령을 통해 이미지를 푸시하거나 풀할 수 있다. 기본 레지스트리(도커허브)가 아닌 레지스트리로 작업하면 이미지 태그 이름 앞에 해당 이름을 붙이자.

```shell
$ docker pull k8s/gcr.io/echoserver:1.4
```

이러한 이미지를 컨테이너로 실행하는 방법을 알아보자.

# 정리


