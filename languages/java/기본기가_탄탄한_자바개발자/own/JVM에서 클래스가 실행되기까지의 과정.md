<!-- Date: 2025-02-09 -->
<!-- Update Date: 2025-02-09 -->
<!-- File ID: 97d78381-e134-4f72-b6f6-8e653b9f99c3 -->
<!-- Author: Seoyeon Jang -->

# JVM?

JVM을 바라보는 한가지 방법은 **실행 컨테이너**라고 보는 것이다. 이 관점에서 JVM의 목적은 클래스 파일을 소비하고 그 안에 포함된 바이트코드를 실행하는 것이다. 이를 위해 JVM은 클래스 파일의 내용을
바이트 데이터 스트림으로 조회해서 사용 가능한 형태로 변환한 후 실행 상태에 추가해야 한다.

# 클래스 로딩?

실행 중인 JVM 프로세스에 새로운 클래스를 통합하는 프로세스이다. 개발자가 실행가능한 JAR 파일이나 기본 애플리케이션 클래스의 이름(클래스패스에 있어야 함)을 제공하면 JVM이 해당 클래스를 찾아서 실행한다.
모든 애플리케이션 의존성(예: JDK 이외의 라이브러리)도 클래스 패스에 있어야 하는데, JVM은 이러한 의존성도 찾아서 로드한다.

# .class 파일?

JVM에서 실행하려는 모든 언어는 이 형식을 준수해야 한다. 클래스는 자바 플랫폼이 이해하고, 실행하는 프로그램 코드의 기본 단위이다.

# 클래스 로딩을 해보자

```text
Class<?> clazz = Class.forName("MyClass");
```

이렇게 함으로써 MyClass라는 클래스를 현재 실행 상태로 로드한다. JVM은 먼저 MyClass라는 이름에 해당하는 클래스 파일을 찾안 다음, 해당 파일에 포함된 클래스를 해석한다. 이러한 단계는 네이티브
코드에서 수행되며, 핫스팟에서는 `JVM_DefineClass()`라는 네이티브 메서드가 이를 담당한다.

사실 실제 프로세스는 높은 수준에서 네이티브 코드가 JVM의 내부 표현(이를 klass라고 하며 자바 객체가 아니다.)을 빌드하는 것이다. 그다음 클래스 파일에서 klass를 성공적으로 추출하면, JVM은
klass의 자바 미러를 생성하고 이는 Class 객체로 자바 코드에 반환된다.

그 후에야 실행중인 시스템에서 해당 타입을 나타내는 Class 객체를 사용할 수 있으며, 해당 클래스의 새로운 인스턴스를 생성할 수 있다. `clazz`는 MyClass 타입에 해당하는 Class 객체를 보유하게
된다.

> 위 절차는 메인 애플리케이션 클래스, 그에 따른 의존성과 프로그램 시작 후 필요한 다른 모든 클래스에서도 사용된다.

# 로딩과 링킹

앞서 JVM이 클래스파일의 내용을 바이트 데이터 스트림으로 조회해서 사용가능한 형태로 변환한 후 실행 상태에 추가한다고 했다. 이 절차를 로딩과 링킹이라고 한다.

# Class 객체

로딩과 링킹 프로세스의 최종 결과는 Class 객체다. 이제 JVM에서 완전히 작동할 수 있다. Class 객체는 일반 자바 객체로, 다른 객체와 마찬가지로 자바 힙에 존재한다.
Class 객체는 메서드, 필드, 생성자 등에 대한 간접적인 액세스를 위해 리플렉션 API와 함께 사용할 수 있다. Class 객체에는 Method, Field 그리고 클래스 멤버에 해당하는 다른 객체에 대한 참조가 존재한다.



