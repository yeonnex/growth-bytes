<!-- Date: 24. 12. 25. } -->
<!-- File ID: 34ba7bf3-df9d-4e04-aa7f-f032e4bb542d -->
<!-- Author: Seoyeon Jang -->
<!-- Update Date: 25. 01. 01. } -->

# 개요

자바는 전통적으로 **장황한 언어**로 명성이 높았다. 그러나 최근 버전에서는 **타입 추론**을 점점 더 많이 사용하도록 언어가 발전했다.
소스 코드 컴파일러의 이 기능을 사용하면 컴파일러가 프로그램의 일부 타입 정보를 자동으로 처리할 수 있다. 따라서 모든 것을 명시적으로 선언할 필요가 없다.

> 타입 추론의 목적은 상용구를 줄이고 중복을 제거해서 더 간결하고 읽기 쉬운 코드를 만드는 것이다.

자바 7 이전에는 다음과 같은 코드를 보는 것이 일반적이었다.

```java
Map<Integer, Map<String, String>> users = new HashMap<Integer, Map<String, String>>();
```

이는 정수로 식별되는 사용자가 있는데, 해당 사용자가 여러가지 지정된 속성(문자열과 문자열의 매핑으로 모델링된)을 가지고 있음을 선언하는 매우 장황한 방법이다.

소스의 절반이 중복된 문자들이고 어떤 가치도 추가하지 않는다. 따라서 자바 7부터는 다음과 같이 작성해서, 컴파일러가 오른쪽에 있는 타입 정보를 작성해 처리하도록
할 수 있다.

```java
Map<Integer, Map<String, String>> users = new HashMap<>();
```

컴파일러는 우측 표현식에 대한 올바른 타입을 찾아낸다. 축약된 타입 선언이 다이아몬드처럼 보여서 이 형태를 **다이아몬드 구분**이라고 한다.

자바 8에서는 람다 표현식 도입을 지원하기 위해 더 많은 타입 추론이 추가됐다. 다음 예제와 같이 타입 추론 알고리즘이 `s` 의 타입이 String 임을 결론지을 수 있다.

```java
Function<String, Integer> lengthFn = s -> s.length();
```

현대 자바에서는 **로컬 변수 타입 추론**(Local Variable Type Inference, LVTI), 즉 `var`이라고도 하는 기능이 도입돼 타입 추론이 한 단계 더 발전됐다.
이 기능은 자바 10에서 추가됐으며, 값의 타입이 아닌 변수의 타입을 추론할 수 있도록 해준다.

```java
var names = new ArrayList<String>();
```

컴파일러가 타입을 추론할 수 있으려면 프로그래머가 충분한 정보를 제공해야 한다. 예를 들어 다음 코드는 컴파일러가 `fn` 타입을
추론할 수 있는 충분한 타입 정보가 없으므로 컴파일되지 않는다.

```java
var fn = s -> s.length();
```
