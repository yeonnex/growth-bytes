<!-- Date: 2025-01-16 -->
<!-- Update Date: 2025-01-16 -->
<!-- File ID: c8939029-101d-41f4-a741-9c7130759600 -->
<!-- Author: Seoyeon Jang -->

# 개요

먼저 DI와 관련성이 높은 다음 두 가지 주요 개념을 살펴보자.

- 시스템 내의 기능 단위에는 적절한 기능을 수행하기 위해 의존하는 의존성과 구성 정보가 있다.
- 많은 객체 시스템에서는 코드로 표현하기 어렵거나 어색한 의존성이 있다.

우리가 가지고 있어야 할 그림은 동작과 설정을 담은 클래스들과 객체 외부에서 온 의존성이다. 여기서 후자는 보통 객체의 **런타임 와이어링(runtime wiring)**
으로 언급된다. 이 예시에서는 가상의 DI 프레임워크가 클래스로더를 사용해서 런타임 와이어링을 구현하는 방법에 대해 살펴보자.

> **NOTE**
> 여기서의 접근 방식은 스프링 프레임워크의 원래 구현을 단순화한 버전과 같다. 그러나 최신 프로덕션 DI 프레임워크는 훨씬 더 복잡하다. 이 예시는 데모용이다.

```shell
$ java cp <CLASSPATH> org.seoyeon.DIMain /path/to/config.xml
```

DIMain 클래스는 DI 프레임워크의 진입점 클래스다. 이 클래스는 구성 파일을 읽고, 객체들의 시스템을 생성하며, 객체들을 서로 연결한다. DIMain 클래스는 애플리케이션 클래스가 아니라 프레임워크에서 제공되며
완전히 일반적인 클래스다.

또한 애플리케이션의 CLASSPATH에는 세 가지가 포함돼야 한다는 것을 알 수 있다.

1. DI 프레임워크용 JAR 파일
2. config.xml에서 참조하는 애플리케이션 클래스
3. 애플리케이션에 있는 기타(DI가 아닌) 의존성

다음의 구성 파일을 보자.

```xml

<beans>
    <bean id="dao" class="app.ch04.PaymentsDAO">
        <constructor-arg index="0" value="jdbc:postgresql://db.seoyeon.org/payments"></constructor-arg>
        <constructor-arg index="1" value="org.postgresql.Driver"></constructor-arg>
    </bean>
    <bean id="service" class="app.ch04.PaymentService">
        <constructor-arg index="0" ref="dao"/>
    </bean>
</beans>
```

DI 프레임워크는 구성 파일을 사용해서 어떤 객체를 생성할지 결정한다. 이 예제에서는 dao 와 service 빈을 만들어야 하며, 프레임워크는 지정된 인수를 사용해서 각 빈에 대한 생성자를 호출해야 한다.

클래스 로딩은 두 단계로 나누어 진행된다. 첫번째 단계(애플리케이션 클래스로더가 처리)는 DIMain 클래스와 이 클래스가 참조하는 모든 프레임워크 클래스를 로드한다. 그다음 DIMain이 실행을 시작하고 구성
파일의 위치를 main()의 매개변수로 받는다.

이 시점에서 프레임워크는 JVM에서 실행중이지만 config.xml 에 지정된 사용자 클래스는 아직 건드리지 않았다. 실제로 DIMain 이 구성파일을 검사하기 전까지는 프레임워크가 어떤 클래스를 로드할지 알 수
없다.

config.xml에 지정된 애플리케이션 구성을 불러오려면 두번째 단계의 클래스 로딩이 필요하다. 이 예제에서는 커스텀 클래스로더를 사용한다.

먼저 config.xml 파일의 일관성을 검사하고 오류가 없는지 확인한다. 그다음 모든 것이 정상이면 사용자 정의 클래스로더가 CLASSPATH에서 타입을 로드하려고 시도한다. 이 중 하나라도 실패하면 전체
프로세스가 중단돼 런타임 오류가 발생한다.

이 작업이 성공하면 DI 프레임워크는 필요한 객체를 올바른 순서(생성자 매개변수와 함께)로 인스턴스화할 수 있다. 마지막으로 이 모든 과정이 올바르게 완료되면 애플리케이션 컨텍스트가 설정되고 실행을 시작할 수 있다.

이 예제는 가상의 예시라는 점을 다시 한번 강조한다. 여기에 설명된 방식으로 작동하는 간단한 DI프레임워크를 구축하는 것은 전적으로 가능하다. 그러나 DI시스템의 구현은 실제로는 훨씬 더 복잡하다.

다른 예시(인스트루먼테이션 클래스로더)를 살펴보자.

# 정리


