
기본적인 `Queue` 인터페이스는 `java.util` 패키지에 있다. 이는 싱글 스레드 프로그래밍에서도 중요한 패턴일 수 있지만, 우리는 멀티스레드 사용 사례에 초점을 맞출 것이다.

매우 일반적인 사용 사례 중 하나이지 집중할 사용사례는 스레드 간에 작업 단위를 전송하기 위해 큐를 사용하는 것이다. 이 패턴은 `Queue`의 가장 간단한 동시성을 위한 확장인 `BlockingQueue`에 이상적으로 적합하다.

`BlockingQueue`는 다음과 같은 두가지 추가적인 특수한 속성을 가진 큐다.

- 큐에 `put()`을 시도할 때 큐가 가득 차면 `put()`을 호출한 스레드는 공간을 사용할 수 있을 때까지 대기한다.
- 큐에서 `take()`를 시도할 때 큐가 비어있으면 `take()`를 호출한 스레드가 차단된다.

이 두 속성은 매우 유용한데, 한 스레드(또는 스레드 풀)의 처리 속도가 다른 스레드의 처리 속도를 앞지르면 더 빠른 스레드가 강제로 대기하게 돼 전체 시스템을 조절할 수 있기 때문이다.

![[Pasted image 20250317130813.png]]

자바는 `BlockingQueue` 인터페이스의 두가지 기본 구현인 `LinkedBlockingQueue`와 `ArrayBlockingQueue`를 함께 제공한다. 이들은 약간 다른 속성을 제공한다. 예를 들어 배열 기반의 구현은 큐의 크기에 대한 정확한 한계가 알려져 있을 때 매우 효율적이며, 연결 기반의 구현은 특정 상황에서 약간 더 빠를 수 있다. 

예제에서 `BlockingQueue`를 사용해서 계좌 예제를 수정하는 방법을 살펴보자. 예제의 목표는 두 개의 계좌 객체를 동시에 잠글 필요성을 제거하는 것이다. 

## AccountManager

이 클래스는 여러 계좌를 관리하는 시스템에서 두 개의 계좌 간의 동시성 문제를 해결하기 위해 `BlockingQueue`를 사용하여 입금과 출금을 처리하는 방식이다. 이 방식은 여러 스레드에서 계좌의 자원을 안전하게 동시에 처리할 수 있도록 해준다. 각 필드의 그 역할을 알아보자.

1. `ConcurrentHashMap<Integer, Account> accounts`
	- `ConcurrentHashMap`은 스레드 안전한 해시맵이다. 이 맵은 계좌의 ID를 키로 사용하여 게좌 객체를 저장한다. 