
collections.namedtuple 을 이용해 카드 한 장을 나타내는 간단한 클래스를 만들었다. 데이터베이스 레코드처럼 사용자 정의 메서드 없이 일련의 속성으로만 구성된 객체의 클래스를 정의할 때 namedtuple 을 사용한다.

파이썬 데이터 모델에 정의된 특별 메서드를 사용할 때의 장점 두가지를 살펴봤다.

- 클래스 사용자는 표준 연산을 수행하는 메서드 이름을 기억할 필요가 없다.(`.size()`? `.length()`?)

이뿐만이 아니다. `__getItem()__` 메서드는 self.cards의 `[]`에 작업을 위임하므로 우리가 만든 카드 한 벌(deck) 객체는 슬라이싱도 저절로 지원한다.

### 특별 메서드의 용도

먼저 던더메서드, 즉 특별 메서드는 내가 아니라 파이썬 인터프리터가 호출하는 메서드라는 점에 유의해야 한다. 나의 소스코드에서는 `my_object.__len()__`을 직접 호출하지 않고 `len(my_object)`를 호출한다. 

`my_object` 가 사용자 정의 클래스의 인스턴스라면, 파이썬은 내가 구현한 `__len()__` 메서드를 호출한다.

그러나! `list, str, bytearray` 등의 내장형이나 넘파이 배열 같은 확장형을 다룰 때 파이썬 인터프리터는 지름길을 선택한다. C로 작성한 파이썬 가변 크기 컬렉션은 `PyVarObject`라는 `struct`구조체를 가지는데, 이 구조체의 `ob_size`필드에 컬렉션 항목 수가 들어있다. 따라서 `my_object`가 내장객체라면 `len(my_object)` 는 `ob_size` 필드를 읽어 반환하므로 메서드를 호출하는 방식보다 훨씬 빠르다.

종종 특별 메서드는 암묵적으로 호출되기도 한다. 가령 `for i in x:` 문은 실제로는 `iter(x)`를 호출하는데, `__iter__()`를 사용할 수 있으면 `x.__iter()__` 가 호출되고, 그렇지 않으면 FrenchDeck에서처럼 `x.__getitem()` 이 호출된다.

이제부터 특별 메서드의 주요 용법을 알아보자.

### 수치형 흉내내기
사용자 정의 객체가 덧셈(+)등의 연산자에 응답하게 해주는 몇몇 특별 메서드가 있다. 

수학의 2차원 유클리드 벡터를 나타내는 클래스를 구현한다고 가정해보자.

>내장된 `complex`형을 이용해 2차원 벡터를 표현해도 되지만, 이렇게 클래스를 확장해서 n 차원 벡터를 표현할 수도 있다.



